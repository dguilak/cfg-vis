\documentclass[â€¢]{article}
\usepackage{amsmath, synttree}

\begin{document}
Very semi-formally, a Context-Free Grammar\footnote{Sipser, M. (2006). Introduction to the Theory of Computation (Vol. 27). Boston, MA: Thomson Course Technology.} (CFG) $G$ is a 4-tuple of the form
\begin{equation}
	G=(V,\Sigma,R,S)
\end{equation}
where
\begin{enumerate}
	\item $V$ is a finite set of variables (so in the Python file I was showing you the other day, $S$ was the only variable)
	\item $\Sigma$ is a finite set of terminals (the terminals I were using were $a$ and $b$).
	\item $R$ is a relationship from $V$ (a variable) to any number/permutation of different elements from both sets $V$ and $\Sigma$ (the nonterminals). For example a relationship of the form
	\begin{equation}
	S \rightarrow a | S
	\end{equation}
means that the non-terminal value $a$ or the variable $S$ can be derived from the variable $S$ (which is a redundant rule, but you get the idea).
	\item Finally, $S$ is the start variable (I was using a variable of the same name in my file).
\end{enumerate}

The simplified example I'm working on right now (the one I was showing you) is a CFG that describes (can "generate") the language of palindromes over an alphabet that consists only of $a$ and $b$ (so $a$, $aba$, $baab$ are all valid palindromes). So it would have a formal form of $G=(V,\Sigma,R,S)$ where
\begin{enumerate}
	\item $V={S}$ -- The only variable is $S$.
	\item $\Sigma={a,b}$ -- the only two non-terminals are the characters $a$ and $b$, so strings generated by the CFG can only have $a$'s and $b$'s.
	\item $R$ consists of only one rule (this is labeled "production" in that Python file), $S \rightarrow a | b | \epsilon | aSa | bSb$ which means five different expressions can be generated by $S$:
	\begin{itemize}
		\item The non-terminals $a$ or $b$,
		\item The empty string $\epsilon$,
		\item The expressions $aSa$ or $aSb$.
	\end{itemize}
	\item The start variable is $S$.
\end{enumerate}

So as an example, if we wanted to use the CFG to generate the palindrome $baab$ starting with the variable $S$, we would follow these steps:
\begin{enumerate}
	\item $S \rightarrow bSb$
	\item $ \rightarrow baSab$ (the middle $S$ is replaced with $aSa$)
	\item $ \rightarrow baab$ (the middle $S$ is replaced with $\epsilon$, the empty string).
\end{enumerate}

The visualization I've been working on for this grammar is that of an interactive parse tree. If you imagine that the start variable $S$ is the root, each of the possible expressions that can be derived from it could be represented as children of the root (so there would be $a$, $b$, $\epsilon$, $aSa$, etc child nodes). Each of those child nodes would have their own children if they have at least one variable present, otherwise they would be leaves. So I hope to make something that looks like:

\begin{center}
\synttree{5}
[S
[a] [b] [$\epsilon$]
[aSa 
	[aaa] [aba] [aa] [aaSaa [.x etc]] [abSba [.x etc]]
	] [bSb [.x etc]]
]
\end{center}


where start with just the root node displayed, and upon being clicked it will generate and display all of its children nodes which are also clickable and expandable, thus hopefully making CFGs a little easier to visualize! And it will be trivial to expand to more variables and production rules, but will obviously make the parse tree a little more complicated.

\end{document}